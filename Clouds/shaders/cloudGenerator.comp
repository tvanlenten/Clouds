#version 430
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
layout (r32f, binding = 0) uniform image3D volume;
layout (std430, binding = 2) buffer worleyNoisePointBuffer
{
    vec4 worleyPoints[];
};

uniform ivec3 volumeDims;
uniform int numCellsPerAxis;
uniform bool invert;

//float hash( float n )
//{
//    return fract(sin(n)*43758.5453);
//}
//
//vec3 hash3( float n )
//{
//    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));
//}
//
//float sdSphere(vec3 p, float r)
//{
//	return length(p) - r;
//}

int ivecMin3 (ivec3 v) {
  return min (min (v.x, v.y), v.z);
}

int ivecMax3 (ivec3 v) {
  return max (max (v.x, v.y), v.z);
}

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

ivec3[27] cellAdjacentOffsets = {
	ivec3(-1, 1, 1), ivec3(0, 1, 1), ivec3(1, 1, 1), // Top Back
	ivec3(-1, 1, 0), ivec3(0, 1, 0), ivec3(1, 1, 0), // Top center
	ivec3(-1, 1, -1), ivec3(0, 1, -1), ivec3(1, 1, -1), // Top front

	ivec3(-1, 0, 1), ivec3(0, 0, 1), ivec3(1, 0, 1), // Center Back
	ivec3(-1, 0, 0), ivec3(0, 0, 0), ivec3(1, 0, 0), // Center center
	ivec3(-1, 0, -1), ivec3(0, 0, -1), ivec3(1, 0, -1), // Center front

	ivec3(-1, -1, 1), ivec3(0, -1, 1), ivec3(1, -1, 1), // Bottom Back
	ivec3(-1, -1, 0), ivec3(0, -1, 0), ivec3(1, -1, 0), // Bottom center
	ivec3(-1, -1, -1), ivec3(0, -1, -1), ivec3(1, -1, -1) // Bottom front
};

float worley(int numCells, vec3 samplePos)
{
	ivec3 cellID = ivec3(floor(samplePos * numCells));
	float minSqrDst = 1.0;

	// loop over current and all adjacent cells to find closest point to samplePos
	for (int cellAdjacentIndex = 0; cellAdjacentIndex < 27; cellAdjacentIndex++)
	{
		ivec3 adjCellID = cellID + cellAdjacentOffsets[cellAdjacentIndex];
		// Check if cell is outside of volume, if so, wrap around to other side for seamless tiling
		if (ivecMin3(adjCellID) == -1 || ivecMax3(adjCellID) == numCells) 
		{
			ivec3 wrappedCellID = (adjCellID + numCells) % ivec3(numCells);
			int adjCellIndex = wrappedCellID.x + numCells * (wrappedCellID.y + wrappedCellID.z * numCells);
			vec3 wrappedPoint = worleyPoints[adjCellIndex].xyz;
	
			for (int wrapOffsetIndex = 0; wrapOffsetIndex < 27; wrapOffsetIndex++) {
				vec3 sampleOffset = samplePos - (wrappedPoint + cellAdjacentOffsets[wrapOffsetIndex]);
				minSqrDst = min(minSqrDst, dot(sampleOffset, sampleOffset));
			}
		}
		// The Adjacent cell is inside the cloud volume, calculate sqrDst from samplePos to cell point
		else 
		{
			int adjCellIndex = adjCellID.x + numCells * (adjCellID.y + adjCellID.z * numCells);
			vec3 sampleOffset = samplePos - worleyPoints[adjCellIndex].xyz;
			minSqrDst = min(minSqrDst, dot(sampleOffset, sampleOffset));
		}
	}
	
	return sqrt(minSqrDst);
}

void main()
{
	ivec3 voxelCoord = ivec3(gl_GlobalInvocationID.xyz);
	vec3 uvw = vec3(voxelCoord) / vec3(volumeDims);

	float density = worley(numCellsPerAxis, uvw);
	if (invert)
	{
		density = 1.0 - density;
	}
	imageStore(volume, voxelCoord, vec4(map(density, 0.7, 1.0, 0.0, 1.0), 0.0, 0.0, 0.0));
}