#version 430
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
layout (rgba32f, binding = 0) uniform image3D volume;
layout (std430, binding = 2) buffer worleyNoisePointBuffer
{
    vec4 worleyPoints[];
};

uniform ivec3 volumeDims;
uniform int numCellsPerAxis;
uniform bool invert;
uniform int channel;

int ivecMin3 (ivec3 v) {
  return min (min (v.x, v.y), v.z);
}

int ivecMax3 (ivec3 v) {
  return max (max (v.x, v.y), v.z);
}

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

ivec3[27] cellAdjacentOffsets = {
	ivec3(-1, 1, 1), ivec3(0, 1, 1), ivec3(1, 1, 1), // Top Back
	ivec3(-1, 1, 0), ivec3(0, 1, 0), ivec3(1, 1, 0), // Top center
	ivec3(-1, 1, -1), ivec3(0, 1, -1), ivec3(1, 1, -1), // Top front

	ivec3(-1, 0, 1), ivec3(0, 0, 1), ivec3(1, 0, 1), // Center Back
	ivec3(-1, 0, 0), ivec3(0, 0, 0), ivec3(1, 0, 0), // Center center
	ivec3(-1, 0, -1), ivec3(0, 0, -1), ivec3(1, 0, -1), // Center front

	ivec3(-1, -1, 1), ivec3(0, -1, 1), ivec3(1, -1, 1), // Bottom Back
	ivec3(-1, -1, 0), ivec3(0, -1, 0), ivec3(1, -1, 0), // Bottom center
	ivec3(-1, -1, -1), ivec3(0, -1, -1), ivec3(1, -1, -1) // Bottom front
};

float worley(int numCells, vec3 samplePos)
{
	ivec3 cellID = ivec3(floor(samplePos * numCells));
	float minSqrDst = 1.0;

	// loop over current and all adjacent cells to find closest point to samplePos
	for (int cellAdjacentIndex = 0; cellAdjacentIndex < 27; cellAdjacentIndex++)
	{
		ivec3 adjCellID = cellID + cellAdjacentOffsets[cellAdjacentIndex];
		// Check if cell is outside of volume, if so, wrap around to other side for seamless tiling
		if (ivecMin3(adjCellID) == -1 || ivecMax3(adjCellID) == numCells) 
		{
			ivec3 wrappedCellID = (adjCellID + numCells) % ivec3(numCells);
			int adjCellIndex = wrappedCellID.x + numCells * (wrappedCellID.y + wrappedCellID.z * numCells);
			vec3 wrappedPoint = worleyPoints[adjCellIndex].xyz;
	
			for (int wrapOffsetIndex = 0; wrapOffsetIndex < 27; wrapOffsetIndex++)
			{
				vec3 sampleOffset = samplePos - (wrappedPoint + cellAdjacentOffsets[wrapOffsetIndex]);
				minSqrDst = min(minSqrDst, dot(sampleOffset, sampleOffset));
			}
		}
		// The Adjacent cell is inside the cloud volume, calculate sqrDst from samplePos to cell point
		else 
		{
			int adjCellIndex = adjCellID.x + numCells * (adjCellID.y + adjCellID.z * numCells);
			vec3 sampleOffset = samplePos - worleyPoints[adjCellIndex].xyz;
			minSqrDst = min(minSqrDst, dot(sampleOffset, sampleOffset));
		}
	}
	
	return sqrt(minSqrDst);
}

const mat3 mm= mat3( 0.00,  0.80,  0.60,
                    -0.80,  0.36, -0.48,
                    -0.60, -0.48,  0.64 );

void main()
{
	ivec3 voxelCoord = ivec3(gl_GlobalInvocationID.xyz);
	vec3 uvw = vec3(voxelCoord) / vec3(volumeDims);

	vec4 prevChannels = imageLoad(volume, voxelCoord);

	float density = worley(numCellsPerAxis, uvw);
	if (invert)
	{
		density = 1.0 - density;
	}

	float cellSize = 1.0 / numCellsPerAxis;

	density = smoothstep(1.0 - cellSize, 1.0, density);

	vec4 res;
	switch(channel)
	{
		case 0:
			res = vec4(density, prevChannels.gba);
			break;
		case 1:
			res = vec4(prevChannels.r, density, prevChannels.ba);
			break;
		case 2:
			res = vec4(prevChannels.rg, density, prevChannels.b);
			break;
		case 3:
			res = vec4(prevChannels.rgb, density);
			break;
	}

	imageStore(volume, voxelCoord, res);
}